# ab2 内存管理
                         0  
|  Real Mode IDT      |  4kb Bios interrupt vector table  
|                     |    
|  boot SECTOR        | 0x7c00 where Boot loader loaded  
|                     |     
|  ELF header (4KB)   | 0x10000  load kernel code to 0x10000 then call i386——init  
|                     |
|                     | 640kb  
|  Bios video ram     |  
|  Kernel code   　   | 1MB  
|  Page Directory     |   


![image](https://upload-images.jianshu.io/upload_images/286774-73004835aee1e4bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

>> 在启用分页前，页目录所在的物理页面的首地址需要存放到 CR3 寄存器中

>> cpu 在进行页式转换时会自动从CR3中取得页目录物理地址   =======CR3： page table dirctory address

>> linear address 的 最高10位 +CR3 ===============page table address

>> page table address + linear address 的中间10位 ========= Page frame 的adress

>> page frame address + linear address 的底 12位 ===== true physic address

**在JOS中，为了简单起见，只用了一个页目录表，整个系统的线性地址空间4GB是被内核和所有其他的用户程序所共用的。由于CPU 和内存速度的不匹配，这样地址翻译时势必会降低系统的效率。为了提高地址翻译的速度，x86处理器引入了地址翻译缓存TLB（旁路转换缓冲）来缓存最近翻译过的地址。当然缓存之后会引入缓存和内存中页表内容不一致的问题，可以通过重载CR3使整个TLB内容失效或者通过 invlpg 指令。

### marco

```

// 线性地址分为如下三部分
//
// +--------10------+-------10-------+---------12----------+
// | Page Directory |   Page Table   | Offset within Page  |
// |      Index     |      Index     |                     |
// +----------------+----------------+---------------------+
//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/
//  \---------- PGNUM(la) ----------/
//

// 页目录和页表的一些常量定义
#define NPDENTRIES  1024   //每个页目录的页目录项数目为1024
#define NPTENTRIES  1024   //每个页表的页表项数目也为1024

#define PGSIZE      4096   // 页大小为4096B，即4KB
#define PGSHIFT     12      // log2(PGSIZE)

#define PTSIZE      (PGSIZE*NPTENTRIES) // 一个页目录项映射内存大小，4MB
#define PTSHIFT     22      // log2(PTSIZE)

#define PTXSHIFT    12       
#define PDXSHIFT    22  

// 页号
#define PGNUM(la)   (((uintptr_t) (la)) >> PTXSHIFT)

// 页目录项索引(高10位)
#define PDX(la)     ((((uintptr_t) (la)) >> PDXSHIFT) & 0x3FF)

// 页表项索引（中间10位）
#define PTX(la)     ((((uintptr_t) (la)) >> PTXSHIFT) & 0x3FF)

// 页内偏移
#define PGOFF(la)   (((uintptr_t) (la)) & 0xFFF)

// 由索引构造线性地址
#define PGADDR(d, t, o) ((void*) ((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))

// 由PageInfo结构得到页面物理地址
static inline physaddr_t
page2pa(struct PageInfo *pp)
{
    return (pp - pages) << PGSHIFT;
}

// 由物理地址得到PageInfo结构体
static inline struct PageInfo*
pa2page(physaddr_t pa) 
{
    if (PGNUM(pa) >= npages)
        panic("pa2page called with invalid pa");
    return &pages[PGNUM(pa)];
}

// 与 page2pa 类似，只不过返回的是 PageInfo 结构 pp 所对应的物理页面的内核首地址(虚拟地址)
static inline void*
page2kva(struct PageInfo *pp)
{
    return KADDR(page2pa(pp));
}
```
### 我们要实现的函数
```
/ 初始化一个页面结构和page_free_list。
void    page_init(void);

// 分配物理页
struct PageInfo *page_alloc(int alloc_flags);

// 释放页面，将页面加入page_free_list
void    page_free(struct PageInfo *pp);

// 将物理页pp映射到虚拟地址va，权限设置为 perm | PTE_P
int page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm);

// 移除虚拟地址va的映射
void    page_remove(pde_t *pgdir, void *va);

// 返回虚拟地址va映射的物理页的PageInfo地址
struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store);

// 给定页目录地址pgdir，检查虚拟地址va是否可以用页表翻译，若能，返回页表项地址，
// 否则根据需要创建页表项并返回页表项的内核地址，注意不是物理地址。
pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);
由于 JOS 只用了一个页目录，不像现代操作系统那样每个都有自己的页目录，所以整个系统的线性地址只有 4GB。JOS中内存组织如下图所示：
```
![image](https://upload-images.jianshu.io/upload_images/286774-70ab857ebcd75702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)


```
   boot_alloc(uint32_t n)
  {
   static char *nextfree;
   char *result;
   // Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
  //boot_alloc 仅仅在第一次系统启动时使用
  //作用是分配足够大的chunk，通过更新 Roundup(end+ n,PGSIZE)
  result = nextfree;
  nextfree = ROUNDUP(nextfree+n,PGSIZE);
  
  
   
  }
```
### mem_init  
// Set up a two-level page table:    建立一个pagedir page table
//    kern_pgdir is its linear (virtual) address of the root
//
// This function only sets up the kernel part of the address space
// (ie. addresses >= UTOP).  The user part of the address space
// will be set up later.
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
```
kernel space in jos start at eec00000 end at 0xf0000000  20M
void mem_init(void)
{
  uint32_t cr0;
	size_t n;
  i386_detect_memory();// Find out how much memory the machine has (npages & npages_basemem).
	
  kern_pgdir = (pde_t *) boot_alloc(PGSIZE);// create initial page directory.
	memset(kern_pgdir, 0, PGSIZE);
  kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
   
  struct PageInfo *page[npages]；// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
  memset（page，npages，sizeof（struct PageInfo））
	                                                    // The kernel uses this array to keep track of physical pages: for
	                                                   // each physical page, there is a corresponding struct PageInfo in this
	                                                  // array.  'npages' is the number of physical pages in memory.  Use memset
	                                                 // to initialize all fields of each struct PageInfo to zero
  // Map 'pages' read-only by the user at linear address UPAGES
	// Permissions:
	//    - the new image at UPAGES -- kernel R, user R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
  pages

}   
```
```
page_init()
{
  
	// goal ：我们要知道什么page已经被使用，就用page_init标记为used，未被使用的page 就被init 为free 状态
	//        标记物理的page0页已经被使用的用来保存 IDT 和 BIOS结构，pageinit函数里 page0是used
  // (1) 4K到 napge_basemem的物理页是未被系统使用的
	// (2) IO hole [IOPHYSMEM, EXTPHYSMEM), which must never be allocated.
	// (3) Then extended memory [EXTPHYSMEM, ...).Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for page tables and other data structures?
	//  
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	
void
page_init(void)
{
    // 1）第0页不用，留给中断描述符表
    // 2）第1-159页可以使用，加入空闲链表（npages_basemem为160，即640K以下内存)
    // 3）640K-1M空间保留给BIOS和显存，不能加入空闲链表
    // 4）1M以上空间中除去kernel已经占用的页，其他都可以使用
    size_t i;
    for (i = 1; i < npages_basemem; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }

    char *nextfree = boot_alloc(0);  //这个nextfree 指向了 kern code 所占用的最后的地址
    size_t kern_end_page = PGNUM(PADDR(nextfree));  //kern code last页的 index
    cprintf("kern end pages:%d\n", kern_end_page);

    for (i = kern_end_page; i < npages; i++) {   //kerncode 后面都可以free
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }



}
```
```
//从空闲链表取第一个，并更新链表头指向下一个空闲位置，如果指定了alloc_flag，则将PageInfo结构对应的那4KB内存区域清零(用page2kva(page)可以得到对应//面的虚拟地址):
struct PageInfo *
page_alloc(int alloc_flags)
{
    if (page_free_list) {
        struct PageInfo *result = page_free_list;
        page_free_list = page_free_list->pp_link;
        if (alloc_flags & ALLOC_ZERO) {
            memset(page2kva(result), 0, PGSIZE);
        }
        return result;
    }
    return NULL;
}
```
```
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
    int pde_index = PDX(va);   //linear address 的高10位
    int pte_index = PTX(va);   //linear address 的 中间10位
    pde_t *pde = &pgdir[pde_index];  //   Page table entry
    if (!(*pde & PTE_P)) {          //无权限or pte不存在    
        if (create) {             // create 一个 page（physical address） 给pte去mapping                               
            struct PageInfo *page = page_alloc(ALLOC_ZERO);
            if (!page) return NULL;

            page->pp_ref++;
            *pde = page2pa(page) | PTE_P | PTE_U | PTE_W;    //让PTE 指向 刚刚created page的物理地址
        } else { 
            return NULL;
        }   
    }   

    pte_t *p = (pte_t *) KADDR(PTE_ADDR(*pde));
    return &p[pte_index];
}
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)//将pa 和 va 联系起来
{
    int pages = PGNUM(size);
    for (int i = 0; i < pages; i++) {
        pte_t *pte = pgdir_walk(pgdir, (void *)va, 1);
        if (!pte) {
            panic("boot_map_region panic: out of memory");
        }
        *pte = pa | perm | PTE_P;      // va所指向的 pte 指向 pa
        va += PGSIZE, pa += PGSIZE;     // 到下一个我们需要mapping 的地址
        
    }
}
```
